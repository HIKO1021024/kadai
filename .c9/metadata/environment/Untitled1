{"changed":true,"filter":false,"title":"Untitled1","tooltip":"/Untitled1","value":"  class CombinationsItr(n: Int) extends AbstractIterator[Repr] {\n    // generating all nums such that:\n    // (1) nums(0) + .. + nums(length-1) = n\n    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1\n    private val (elms, cnts, nums) = init()\n    private val offs = cnts.scanLeft(0)(_ + _)\n    private var _hasNext = true\n\n    def hasNext = _hasNext\n    def next(): Repr = {\n      if (!hasNext)\n        Iterator.empty.next()\n\n      /* Calculate this result. */\n      val buf = self.newBuilder\n      for(k <- 0 until nums.length; j <- 0 until nums(k))\n        buf += elms(offs(k)+j)\n      val res = buf.result()\n\n      /* Prepare for the next call to next. */\n      var idx = nums.length - 1\n      while (idx >= 0 && nums(idx) == cnts(idx))\n        idx -= 1\n\n      idx = nums.lastIndexWhere(_ > 0, idx - 1)\n\n      if (idx < 0)\n        _hasNext = false\n      else {\n        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`\n        var sum = 1\n        var i = idx + 1\n        while (i < nums.length) {\n          sum += nums(i)\n          i += 1\n        }\n        nums(idx) -= 1\n        for (k <- (idx+1) until nums.length) {\n          nums(k) = sum min cnts(k)\n          sum -= nums(k)\n        }\n      }\n\n      res\n    }\n\n    /** Rearrange seq to newSeq a0a0..a0a1..a1...ak..ak such that\n     *  seq.count(_ == aj) == cnts(j)\n     *\n     *  @return     (newSeq,cnts,nums)\n     */\n    private def init(): (IndexedSeq[A], Array[Int], Array[Int]) = {\n      val m = mutable.HashMap[A, Int]()\n\n      // e => (e, weight(e))\n      val (es, is) = (thisCollection map (e => (e, m.getOrElseUpdate(e, m.size))) sortBy (_._2)).unzip\n      val cs = new Array[Int](m.size)\n      is foreach (i => cs(i) += 1)\n      val ns = new Array[Int](cs.length)\n\n      var r = n\n      0 until ns.length foreach { k =>\n        ns(k) = r min cs(k)\n        r -= ns(k)\n      }\n      (es.toIndexedSeq, cs, ns)\n    }\n  }","undoManager":{"mark":-2,"position":13,"stack":[[{"start":{"row":0,"column":0},"end":{"row":45,"column":0},"action":"insert","lines":["private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }",""],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":45,"column":0},"action":"remove","lines":["private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }",""],"id":2},{"start":{"row":0,"column":0},"end":{"row":255,"column":0},"action":"insert","lines":["  private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }","","    /** Rearrange seq to newSeq a0a0..a0a1..a1...ak..ak such that","     *  seq.count(_ == aj) == cnts(j)","     *","     *  @return     (newSeq,cnts,nums)","     */","    private def init(): (IndexedSeq[A], Array[Int], Array[Int]) = {","      val m = mutable.HashMap[A, Int]()","","      // e => (e, weight(e))","      val (es, is) = (thisCollection map (e => (e, m.getOrElseUpdate(e, m.size))) sortBy (_._2)).unzip","      val cs = new Array[Int](m.size)","      is foreach (i => cs(i) += 1)","      val ns = new Array[Int](cs.length)","","      var r = n","      0 until ns.length foreach { k =>","        ns(k) = r min cs(k)","        r -= ns(k)","      }","      (es.toIndexedSeq, cs, ns)","    }","  }","","  def reverse: Repr = {","    var xs: List[A] = List()","    for (x <- this)","      xs = x :: xs","    val b = newBuilder","    b.sizeHint(this)","    for (x <- xs)","      b += x","    b.result()","  }","","  def reverseMap[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {","    var xs: List[A] = List()","    for (x <- this)","      xs = x :: xs","    val b = bf(repr)","    for (x <- xs)","      b += f(x)","","    b.result()","  }","","  /** An iterator yielding elements in reversed order.","   *","   *   $willNotTerminateInf","   *","   * Note: `xs.reverseIterator` is the same as `xs.reverse.iterator` but might be more efficient.","   *","   *  @return  an iterator yielding the elements of this $coll in reversed order","   */","  def reverseIterator: Iterator[A] = toCollection(reverse).iterator","","  def startsWith[B](that: GenSeq[B], offset: Int): Boolean = {","    val i = this.iterator drop offset","    val j = that.iterator","    while (j.hasNext && i.hasNext)","      if (i.next != j.next)","        return false","","    !j.hasNext","  }","","  def endsWith[B](that: GenSeq[B]): Boolean = {","    val i = this.iterator.drop(length - that.length)","    val j = that.iterator","    while (i.hasNext && j.hasNext)","      if (i.next != j.next)","        return false","","    !j.hasNext","  }","","  /** Finds first index where this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  the first index such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def indexOfSlice[B >: A](that: GenSeq[B]): Int = indexOfSlice(that, 0)","","  /** Finds first index after or at a start index where this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @param  from    the start index","   *  @return  the first index `>= from` such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def indexOfSlice[B >: A](that: GenSeq[B], from: Int): Int =","    if (this.hasDefiniteSize && that.hasDefiniteSize) {","      val l = length","      val tl = that.length","      val clippedFrom = math.max(0, from)","      if (from > l) -1","      else if (tl < 1) clippedFrom","      else if (l < tl) -1","      else SeqLike.kmpSearch(thisCollection, clippedFrom, l, that.seq, 0, tl, forward = true)","    }","    else {","      var i = from","      var s: Seq[A] = thisCollection drop i","      while (!s.isEmpty) {","        if (s startsWith that)","          return i","","        i += 1","        s = s.tail","      }","      -1","    }","","  /** Finds last index where this $coll contains a given sequence as a slice.","   *  $willNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  the last index such that the elements of this $coll starting a this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def lastIndexOfSlice[B >: A](that: GenSeq[B]): Int = lastIndexOfSlice(that, length)","","  /** Finds last index before or at a given end index where this $coll contains a given sequence as a slice.","   *  @param  that    the sequence to test","   *  @param  end     the end index","   *  @return  the last index `<= end` such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def lastIndexOfSlice[B >: A](that: GenSeq[B], end: Int): Int = {","    val l = length","    val tl = that.length","    val clippedL = math.min(l-tl, end)","","    if (end < 0) -1","    else if (tl < 1) clippedL","    else if (l < tl) -1","    else SeqLike.kmpSearch(thisCollection, 0, clippedL+tl, that.seq, 0, tl, forward = false)","  }","","  /** Tests whether this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  `true` if this $coll contains a slice with the same elements","   *           as `that`, otherwise `false`.","   */","  def containsSlice[B](that: GenSeq[B]): Boolean = indexOfSlice(that) != -1","","  /** Tests whether this $coll contains a given value as an element.","   *  $mayNotTerminateInf","   *","   *  @param elem  the element to test.","   *  @return     `true` if this $coll has an element that is equal (as","   *              determined by `==`) to `elem`, `false` otherwise.","   */","  def contains[A1 >: A](elem: A1): Boolean = exists (_ == elem)","","  /** Produces a new sequence which contains all elements of this $coll and also all elements of","   *  a given sequence. `xs union ys`  is equivalent to `xs ++ ys`.","   *","   *  @param that   the sequence to add.","   *  @tparam B     the element type of the returned $coll.","   *  @tparam That  $thatinfo","   *  @param bf     $bfinfo","   *  @return       a new collection of type `That` which contains all elements of this $coll","   *                followed by all elements of `that`.","   *  @usecase def union(that: Seq[A]): $Coll[A]","   *    @inheritdoc","   *","   *    Another way to express this","   *    is that `xs union ys` computes the order-preserving multi-set union of `xs` and `ys`.","   *    `union` is hence a counter-part of `diff` and `intersect` which also work on multi-sets.","   *","   *    $willNotTerminateInf","   *","   *    @return       a new $coll which contains all elements of this $coll","   *                  followed by all elements of `that`.","   */","  override def union[B >: A, That](that: GenSeq[B])(implicit bf: CanBuildFrom[Repr, B, That]): That =","    this ++ that","","  /** Computes the multiset difference between this $coll and another sequence.","   *","   *  @param that   the sequence of elements to remove","   *  @tparam B     the element type of the returned $coll.","   *  @return       a new collection of type `That` which contains all elements of this $coll","   *                except some of occurrences of elements that also appear in `that`.","   *                If an element value `x` appears","   *                ''n'' times in `that`, then the first ''n'' occurrences of `x` will not form","   *                part of the result, but any following occurrences will.","   *  @usecase def diff(that: Seq[A]): $Coll[A]","   *    @inheritdoc","   *","   *    $willNotTerminateInf","   *","   *    @return       a new $coll which contains all elements of this $coll","   *                  except some of occurrences of elements that also appear in `that`.","   *                  If an element value `x` appears","   *                  ''n'' times in `that`, then the first ''n'' occurrences of `x` will not form","   *                  part of the result, but any following occurrences will.","   */","  def diff[B >: A](that: GenSeq[B]): Repr = {","    val occ = occCounts(that.seq)","    val b = newBuilder","    for (x <- this) {","      val ox = occ(x)  // Avoid multiple map lookups","      if (ox == 0) b += x","      else occ(x) = ox - 1","    }","    b.result()","  }",""]}],[{"start":{"row":24,"column":46},"end":{"row":24,"column":47},"action":"insert","lines":["a"],"id":3}],[{"start":{"row":24,"column":47},"end":{"row":68,"column":5},"action":"insert","lines":[" private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }"],"id":4}],[{"start":{"row":0,"column":0},"end":{"row":299,"column":0},"action":"remove","lines":["  private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1a private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    })","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }","","    /** Rearrange seq to newSeq a0a0..a0a1..a1...ak..ak such that","     *  seq.count(_ == aj) == cnts(j)","     *","     *  @return     (newSeq,cnts,nums)","     */","    private def init(): (IndexedSeq[A], Array[Int], Array[Int]) = {","      val m = mutable.HashMap[A, Int]()","","      // e => (e, weight(e))","      val (es, is) = (thisCollection map (e => (e, m.getOrElseUpdate(e, m.size))) sortBy (_._2)).unzip","      val cs = new Array[Int](m.size)","      is foreach (i => cs(i) += 1)","      val ns = new Array[Int](cs.length)","","      var r = n","      0 until ns.length foreach { k =>","        ns(k) = r min cs(k)","        r -= ns(k)","      }","      (es.toIndexedSeq, cs, ns)","    }","  }","","  def reverse: Repr = {","    var xs: List[A] = List()","    for (x <- this)","      xs = x :: xs","    val b = newBuilder","    b.sizeHint(this)","    for (x <- xs)","      b += x","    b.result()","  }","","  def reverseMap[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {","    var xs: List[A] = List()","    for (x <- this)","      xs = x :: xs","    val b = bf(repr)","    for (x <- xs)","      b += f(x)","","    b.result()","  }","","  /** An iterator yielding elements in reversed order.","   *","   *   $willNotTerminateInf","   *","   * Note: `xs.reverseIterator` is the same as `xs.reverse.iterator` but might be more efficient.","   *","   *  @return  an iterator yielding the elements of this $coll in reversed order","   */","  def reverseIterator: Iterator[A] = toCollection(reverse).iterator","","  def startsWith[B](that: GenSeq[B], offset: Int): Boolean = {","    val i = this.iterator drop offset","    val j = that.iterator","    while (j.hasNext && i.hasNext)","      if (i.next != j.next)","        return false","","    !j.hasNext","  }","","  def endsWith[B](that: GenSeq[B]): Boolean = {","    val i = this.iterator.drop(length - that.length)","    val j = that.iterator","    while (i.hasNext && j.hasNext)","      if (i.next != j.next)","        return false","","    !j.hasNext","  }","","  /** Finds first index where this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  the first index such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def indexOfSlice[B >: A](that: GenSeq[B]): Int = indexOfSlice(that, 0)","","  /** Finds first index after or at a start index where this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @param  from    the start index","   *  @return  the first index `>= from` such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def indexOfSlice[B >: A](that: GenSeq[B], from: Int): Int =","    if (this.hasDefiniteSize && that.hasDefiniteSize) {","      val l = length","      val tl = that.length","      val clippedFrom = math.max(0, from)","      if (from > l) -1","      else if (tl < 1) clippedFrom","      else if (l < tl) -1","      else SeqLike.kmpSearch(thisCollection, clippedFrom, l, that.seq, 0, tl, forward = true)","    }","    else {","      var i = from","      var s: Seq[A] = thisCollection drop i","      while (!s.isEmpty) {","        if (s startsWith that)","          return i","","        i += 1","        s = s.tail","      }","      -1","    }","","  /** Finds last index where this $coll contains a given sequence as a slice.","   *  $willNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  the last index such that the elements of this $coll starting a this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def lastIndexOfSlice[B >: A](that: GenSeq[B]): Int = lastIndexOfSlice(that, length)","","  /** Finds last index before or at a given end index where this $coll contains a given sequence as a slice.","   *  @param  that    the sequence to test","   *  @param  end     the end index","   *  @return  the last index `<= end` such that the elements of this $coll starting at this index","   *           match the elements of sequence `that`, or `-1` of no such subsequence exists.","   */","  def lastIndexOfSlice[B >: A](that: GenSeq[B], end: Int): Int = {","    val l = length","    val tl = that.length","    val clippedL = math.min(l-tl, end)","","    if (end < 0) -1","    else if (tl < 1) clippedL","    else if (l < tl) -1","    else SeqLike.kmpSearch(thisCollection, 0, clippedL+tl, that.seq, 0, tl, forward = false)","  }","","  /** Tests whether this $coll contains a given sequence as a slice.","   *  $mayNotTerminateInf","   *  @param  that    the sequence to test","   *  @return  `true` if this $coll contains a slice with the same elements","   *           as `that`, otherwise `false`.","   */","  def containsSlice[B](that: GenSeq[B]): Boolean = indexOfSlice(that) != -1","","  /** Tests whether this $coll contains a given value as an element.","   *  $mayNotTerminateInf","   *","   *  @param elem  the element to test.","   *  @return     `true` if this $coll has an element that is equal (as","   *              determined by `==`) to `elem`, `false` otherwise.","   */","  def contains[A1 >: A](elem: A1): Boolean = exists (_ == elem)","","  /** Produces a new sequence which contains all elements of this $coll and also all elements of","   *  a given sequence. `xs union ys`  is equivalent to `xs ++ ys`.","   *","   *  @param that   the sequence to add.","   *  @tparam B     the element type of the returned $coll.","   *  @tparam That  $thatinfo","   *  @param bf     $bfinfo","   *  @return       a new collection of type `That` which contains all elements of this $coll","   *                followed by all elements of `that`.","   *  @usecase def union(that: Seq[A]): $Coll[A]","   *    @inheritdoc","   *","   *    Another way to express this","   *    is that `xs union ys` computes the order-preserving multi-set union of `xs` and `ys`.","   *    `union` is hence a counter-part of `diff` and `intersect` which also work on multi-sets.","   *","   *    $willNotTerminateInf","   *","   *    @return       a new $coll which contains all elements of this $coll","   *                  followed by all elements of `that`.","   */","  override def union[B >: A, That](that: GenSeq[B])(implicit bf: CanBuildFrom[Repr, B, That]): That =","    this ++ that","","  /** Computes the multiset difference between this $coll and another sequence.","   *","   *  @param that   the sequence of elements to remove","   *  @tparam B     the element type of the returned $coll.","   *  @return       a new collection of type `That` which contains all elements of this $coll","   *                except some of occurrences of elements that also appear in `that`.","   *                If an element value `x` appears","   *                ''n'' times in `that`, then the first ''n'' occurrences of `x` will not form","   *                part of the result, but any following occurrences will.","   *  @usecase def diff(that: Seq[A]): $Coll[A]","   *    @inheritdoc","   *","   *    $willNotTerminateInf","   *","   *    @return       a new $coll which contains all elements of this $coll","   *                  except some of occurrences of elements that also appear in `that`.","   *                  If an element value `x` appears","   *                  ''n'' times in `that`, then the first ''n'' occurrences of `x` will not form","   *                  part of the result, but any following occurrences will.","   */","  def diff[B >: A](that: GenSeq[B]): Repr = {","    val occ = occCounts(that.seq)","    val b = newBuilder","    for (x <- this) {","      val ox = occ(x)  // Avoid multiple map lookups","      if (ox == 0) b += x","      else occ(x) = ox - 1","    }","    b.result()","  }",""],"id":5},{"start":{"row":0,"column":0},"end":{"row":44,"column":5},"action":"insert","lines":[" private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }"]}],[{"start":{"row":0,"column":0},"end":{"row":44,"column":5},"action":"remove","lines":[" private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }"],"id":6},{"start":{"row":0,"column":0},"end":{"row":67,"column":3},"action":"insert","lines":["  private class CombinationsItr(n: Int) extends AbstractIterator[Repr] {","    // generating all nums such that:","    // (1) nums(0) + .. + nums(length-1) = n","    // (2) 0 <= nums(i) <= cnts(i), where 0 <= i <= cnts.length-1","    private val (elms, cnts, nums) = init()","    private val offs = cnts.scanLeft(0)(_ + _)","    private var _hasNext = true","","    def hasNext = _hasNext","    def next(): Repr = {","      if (!hasNext)","        Iterator.empty.next()","","      /* Calculate this result. */","      val buf = self.newBuilder","      for(k <- 0 until nums.length; j <- 0 until nums(k))","        buf += elms(offs(k)+j)","      val res = buf.result()","","      /* Prepare for the next call to next. */","      var idx = nums.length - 1","      while (idx >= 0 && nums(idx) == cnts(idx))","        idx -= 1","","      idx = nums.lastIndexWhere(_ > 0, idx - 1)","","      if (idx < 0)","        _hasNext = false","      else {","        // OPT: hand rolled version of `sum = nums.view(idx + 1, nums.length).sum + 1`","        var sum = 1","        var i = idx + 1","        while (i < nums.length) {","          sum += nums(i)","          i += 1","        }","        nums(idx) -= 1","        for (k <- (idx+1) until nums.length) {","          nums(k) = sum min cnts(k)","          sum -= nums(k)","        }","      }","","      res","    }","","    /** Rearrange seq to newSeq a0a0..a0a1..a1...ak..ak such that","     *  seq.count(_ == aj) == cnts(j)","     *","     *  @return     (newSeq,cnts,nums)","     */","    private def init(): (IndexedSeq[A], Array[Int], Array[Int]) = {","      val m = mutable.HashMap[A, Int]()","","      // e => (e, weight(e))","      val (es, is) = (thisCollection map (e => (e, m.getOrElseUpdate(e, m.size))) sortBy (_._2)).unzip","      val cs = new Array[Int](m.size)","      is foreach (i => cs(i) += 1)","      val ns = new Array[Int](cs.length)","","      var r = n","      0 until ns.length foreach { k =>","        ns(k) = r min cs(k)","        r -= ns(k)","      }","      (es.toIndexedSeq, cs, ns)","    }","  }"]}],[{"start":{"row":0,"column":8},"end":{"row":0,"column":9},"action":"remove","lines":["e"],"id":17}],[{"start":{"row":0,"column":7},"end":{"row":0,"column":8},"action":"remove","lines":["t"],"id":18}],[{"start":{"row":0,"column":6},"end":{"row":0,"column":7},"action":"remove","lines":["a"],"id":19}],[{"start":{"row":0,"column":5},"end":{"row":0,"column":6},"action":"remove","lines":["v"],"id":20}],[{"start":{"row":0,"column":4},"end":{"row":0,"column":5},"action":"remove","lines":["i"],"id":21}],[{"start":{"row":0,"column":3},"end":{"row":0,"column":4},"action":"remove","lines":["r"],"id":22}],[{"start":{"row":0,"column":2},"end":{"row":0,"column":3},"action":"remove","lines":["p"],"id":23}],[{"start":{"row":0,"column":2},"end":{"row":0,"column":3},"action":"remove","lines":[" "],"id":24}]]},"ace":{"folds":[],"scrolltop":224,"scrollleft":0,"selection":{"start":{"row":16,"column":2},"end":{"row":16,"column":2},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":11,"state":"start","mode":"ace/mode/text"}},"timestamp":1521346202742}