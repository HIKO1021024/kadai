{"changed":true,"filter":false,"title":"Test2.scala","tooltip":"/Test2.scala","value":"//おそらくこの問題はいわゆる「組み合わせ」を問うものだと想定される。\n//よって母数を限りなく減らした上で、組み合わせのリストを生成し、\n//そのリストからA[i]<A[j]を精査する方法が効率が良い。\n//精査する方法だが\n//与えられる配列は必ず2要素以上入っているものを想定している\n\nimport scala.util.Random\n\n  object Kumiawase{\n    def main(args: Array[String]){\n        //まずはランダムな配列Aを作成\n        val r = new Random\n        var A: Array[Int] = Array.empty\n        for(i <- 0 to 3000) A = A :+ r.nextInt(100)\n        //Kも生成\n        val K = r.nextInt(100)\n        //重複はSet型に変換し削除する\n        var B: Set[Int] = A.toSet\n        //combinationsはSetでは使えないのでArray型に戻す\n        A = B.toArray\n        //配列の最低値を取得\n        val mn = A.min;\n        //最低値からKへの必要な数値を算出\n        val T = K - mn \n        //0+(T+最低値)よりも大きな数値は明らかに条件に合致しないため、削除する\n        if(mn < 0) {\n          //最低値が負の数字の場合\n          A = A.filter(_ <= 0+(T + mn * -1) );\n        }else {\n          //そうでない場合\n          A = A.filter(_ <= 0 + T - mn );\n          println(\"そうでない\")\n        }\n        //Aの中から組み合わせを作成\n        var B = A.combinations(2).toArray\n        //組み合わせの中から条件に合致する数値が存在するか調べる\n    }\n       \n    //def Rand_arr(valmin: Long, valmax: Long, arry_max: Long):Array[;] = {\n    //  return a = (1,2,4,7,8)\n    //}\n    \n    def Arrygen(valmax: Int,arry_max: Int):Array[Int] = {\n      \n    }\n  }\n   ","undoManager":{"mark":-2,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":300,"scrollleft":0,"selection":{"start":{"row":17,"column":11},"end":{"row":17,"column":11},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":20,"state":"start","mode":"ace/mode/scala"}},"timestamp":1521337901606}